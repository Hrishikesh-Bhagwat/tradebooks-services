"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var generateId = require('../utils').generateId;

var WebSocket = require('isomorphic-ws');

var WebSocketClient =
/*#__PURE__*/
function () {
  function WebSocketClient(url, options) {
    _classCallCheck(this, WebSocketClient);

    if (!url.startsWith('http')) {
      url = window.location.href;
      var arr = url.split("/");
      url = arr[0] + "//" + arr[2] + '/';
    }

    if (url.startsWith('http')) {
      url = url.replace('http', 'ws');
    }

    url = url + "v1/api/".concat(options.projectId, "/socket/json");
    this.url = url;
    this.options = options;
    this.connected = false;
    this.isConnecting = false;
    this.connectedOnce = false;
    this.callbacks = {};
    this.onReconnectCallbacks = [];
    this.pendingRequests = [];
  }

  _createClass(WebSocketClient, [{
    key: "registerCallback",
    value: function registerCallback(type, cb) {
      // TODO: check if cb is a function
      this.callbacks[type] = cb;
    }
  }, {
    key: "unregisterCallback",
    value: function unregisterCallback(type) {
      delete this.callbacks[type];
    }
  }, {
    key: "registerOnReconnectCallback",
    value: function registerOnReconnectCallback(cb) {
      this.onReconnectCallbacks.push(cb);
    }
  }, {
    key: "connect",
    value: function connect() {
      var _this = this;

      this.isConnecting = true;
      var socket = new WebSocket(this.url);

      socket.onopen = function () {
        _this.isConnecting = false;
        _this.socket = socket;
        _this.connected = true; // perform onconnect callbacks

        if (_this.connectedOnce) {
          _this.onReconnectCallbacks.forEach(function (cb) {
            cb();
          });
        }

        _this.connectedOnce = true; // clear pending requests

        if (_this.connected) {
          _this.pendingRequests.forEach(function (req) {
            _this.socket.send(JSON.stringify(req));
          });

          _this.pendingRequests = [];
        }
      };

      socket.onmessage = function (e) {
        var res = JSON.parse(e.data); // one time callback if id exists

        if (res.id) {
          var _cb = _this.callbacks[res.id];

          if (_cb) {
            _cb(res.data);

            _this.unregisterCallback(res.id);

            return;
          }
        } // Normal callback procedure


        var cb = _this.callbacks[res.type];

        if (cb) {
          cb(res.data);
        }
      };

      socket.onclose = function () {
        _this.connected = false;
        _this.isConnecting = false;
        setTimeout(function () {
          _this.connect();
        }, 5000);
      };

      socket.onerror = function (e) {
        _this.isConnecting = false;
        console.log('Websocket error: ', e);
      };
    }
  }, {
    key: "send",
    value: function send(type, data) {
      var id = generateId();
      var payload = {
        id: id,
        type: type,
        data: Object.assign({}, data, {
          token: this.options.token
        }) // if not connected, then push the message to pending requests and try to connect

      };

      if (!this.connected) {
        this.pendingRequests.push(payload);
        if (!this.isConnecting) this.connect();
        return id;
      } // send the message


      this.socket.send(JSON.stringify(payload));
      return id;
    }
  }, {
    key: "request",
    value: function request(type, data) {
      var _this2 = this;

      var p = new Promise(function (resolve, reject) {
        var isResolved = false;

        var id = _this2.send(type, data);

        var timer = setTimeout(function () {
          reject('Websocket request has timed out');
        }, 10000);

        _this2.registerCallback(id, function (data) {
          if (!isResolved) {
            clearTimeout(timer);
            resolve(data);
          }
        });
      });
      return p;
    }
  }]);

  return WebSocketClient;
}();

module.exports = WebSocketClient;