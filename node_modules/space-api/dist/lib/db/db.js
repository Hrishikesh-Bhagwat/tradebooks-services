"use strict";

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Batch = require('./batch');

var Get = require('./get');

var Insert = require('./insert');

var Update = require('./update');

var Delete = require('./delete');

var PreparedQuery = require('./prepared-query');

var Aggregate = require('./aggregate');

var myURL = require('url');

if (typeof window === 'undefined') {
  global.URL = myURL.URL;
}

var fetchAsync = require('../utils').fetchAsync;
/**
 * The LiveQuery Interface.
 * @external LiveQuery
 * @see {@link https://github.com/spaceuptech/space-api-js/wiki/Realtime}
 */

/**
 * @typedef User
 * @property {string} _id - The user's unique id.
 * @property {string} email The user's email id.
 * @property {string} name The user's name.
 * @property {string} role The user's role.
 */

/**
 * @typedef AuthResponse
 * @property {number} status - The http status code of response.
 * @property {Object} data The response payload.
 * @property {string} data.token The signed token generated for the user.
 * @property {User} data.user Information of the user.
 */

/**
 * Class representing the DB Client Interface.
 * @example 
 * import { API } from 'space-api';
 * 
 * const api = new API('my-project', 'http://localhost:4122');
 * const db = api.DB("mongo");
 */


var DB =
/*#__PURE__*/
function () {
  /**
   * Create an instance of the DB Client Interface. 
   * @param {string} appId 
   * @param {string} url 
   * @param {Object} options
   * @param {string} db
   * @param {Object} realTime 
   */
  function DB(appId, url, options, db, realtime) {
    _classCallCheck(this, DB);

    this.appId = appId;
    this.url = url;
    this.options = options;
    this.db = db;
    this.realtime = realtime;
  }

  _createClass(DB, [{
    key: "beginBatch",
    value: function beginBatch() {
      return new Batch(this.appId, this.url, this.options, this.db);
    }
    /**
     * Returns a DB Get Object
     * @param {string} collection - The collection to query documents.
     * @returns {Get} DB Get Object
     */

  }, {
    key: "get",
    value: function get(collection) {
      return new Get(this.appId, collection, this.url, this.options, this.db, 'all');
    }
    /**
     * Returns a DB Get Object to get one particular object
     * @param {string} collection - The collection to query documents.
     * @returns {Get} DB Get Object
     */

  }, {
    key: "getOne",
    value: function getOne(collection) {
      return new Get(this.appId, collection, this.url, this.options, this.db, 'one');
    }
  }, {
    key: "count",
    value: function count(collection) {
      return new Get(this.appId, collection, this.url, this.options, this.db, 'count');
    }
  }, {
    key: "distinct",
    value: function distinct(collection) {
      return new Get(this.appId, collection, this.url, this.options, this.db, 'distinct');
    }
    /**
     * Returns a DB Insert Object
     * @param {string} collection - The collection to insert documents.
     * @returns {Insert} DB Insert Object
     */

  }, {
    key: "insert",
    value: function insert(collection) {
      return new Insert(this.appId, collection, this.url, this.options, this.db);
    }
    /**
     * Returns a DB Update Object to update all matching documents
     * @param {string} collection - The collection to update documents.
     * @returns {Update} DB Update Object
     */

  }, {
    key: "update",
    value: function update(collection) {
      return new Update(this.appId, collection, this.url, this.options, this.db, 'all');
    }
    /**
     * Returns a DB Update Object to update a particular document
     * @param {string} collection - The collection to update document.
     * @returns {Update} DB Update Object
     */

  }, {
    key: "updateOne",
    value: function updateOne(collection) {
      return new Update(this.appId, collection, this.url, this.options, this.db, 'one');
    }
    /**
     * Returns a DB Update Object to upsert a particular document
     * @param {string} collection - The collection to update document.
     * @returns {Update} DB Update Object
     */

  }, {
    key: "upsert",
    value: function upsert(collection) {
      return new Update(this.appId, collection, this.url, this.options, this.db, 'upsert');
    }
    /**
     * Returns a DB Delete Object
     * @param {string} collection - The collection to delete documents in.
     * @returns {Delete} DB Insert Object
     */

  }, {
    key: "delete",
    value: function _delete(collection) {
      return new Delete(this.appId, collection, this.url, this.options, this.db, 'all');
    }
    /**
     * Returns a DB Delete Object to delete a particular document
     * @param {string} collection - The collection to delete document.
     * @returns {Delete} DB Delete Object
     */

  }, {
    key: "deleteOne",
    value: function deleteOne(collection) {
      return new Delete(this.appId, collection, this.url, this.options, this.db, 'one');
    }
    /**
    * Returns a Prepared Query Object to execute a database prepared query
    * @param {string} id - The id of prepared query.
    * @returns {PreparedQuery} Prepared Query Object
    */

  }, {
    key: "preparedQuery",
    value: function preparedQuery(id) {
      return new PreparedQuery(this.appId, id, this.url, this.options, this.db);
    }
    /**
     * Returns a DB Aggregate Object
     * @param {string} collection - The collection to aggregate documents in.
     * @returns {Delete} DB Insert Object
     */

  }, {
    key: "aggr",
    value: function aggr(collection) {
      return new Aggregate(this.appId, collection, this.url, this.options, this.db, 'all');
    }
  }, {
    key: "aggrOne",
    value: function aggrOne(collection) {
      return new Aggregate(this.appId, collection, this.url, this.options, this.db, 'one');
    }
    /**
     * Returns a LiveQuery Object
     * @param {string} collection - The collection to query documents.
     * @returns {external:LiveQuery} LiveQuery Object
     * @example
     * const onSnapshot = (snapshot, type, changedDoc) => {
     *    console.log(type, snapshot, changedDoc)
     * }
     *
     * const onError = (err) => {
     *   console.log('Operation failed:', err)
     * }
     *
     * let subscription = db.liveQuery('posts').where({}).subscribe(onSnapshot, onError) 
     *
     * // Unsubscribe to clean up
     * subscription.unsubscribe()
     */

  }, {
    key: "liveQuery",
    value: function liveQuery(collection) {
      return this.realtime.liveQuery(this.db, collection);
    }
    /**
     * Fetches the user profile
     * @param {string} id - The unique user id
     * @returns {Promise} Returns a promise containing response from server
     * @example 
     * db.profile(id).then(res => {
     *   if (res.status === 200) {
     *     // res.data.user contains user details
     *     console.log('Response:', res.data.user);
     *     return;
     *   }
     *   // Request failed
     * }).catch(ex => {
     *   // Exception occured while processing request
     * });
     */

  }, {
    key: "profile",
    value: function profile(id) {
      var url = dbURL(this.url, this.db, this.appId, 'auth', "profile/".concat(id));
      return fetchAsync(url, Object.assign({}, this.options, {
        method: 'GET'
      }));
    }
    /**
     * Updates the user profile
     * @param {string} id - The unique user id
     * @param {string} email - The new email id
     * @param {string} name - The new name
     * @param {string} pass - The new password
     * @returns {Promise} Return a promise containing response from server
     * @example 
     * db.editProfile(id, email, name, pass).then(res => {
     *   if (res.status === 200) {
     *     // User account has been updates successfully
     *     return;
     *   }
     *   // Request failed
     * }).catch(ex => {
     *   // Exception occured while processing request
     * });
     */

  }, {
    key: "editProfile",
    value: function editProfile(id, email, name, pass) {
      var body = JSON.stringify({
        update: {
          $set: {
            email: email,
            name: name,
            pass: pass
          }
        }
      });
      var url = dbURL(this.url, this.db, this.appId, 'auth', "edit_profile/".concat(id));
      return fetchAsync(url, Object.assign({}, this.options, {
        method: 'PUT',
        body: body
      }));
    }
    /**
     * Fetches all the user profiles
     * @returns {Promise} Returns a promise containing response from server
     * @example 
     * db.profiles().then(res => {
     *   if (res.status === 200) {
     *     // res.data.users contains user details
     *     console.log('Response:', res.data.users);
     *     return;
     *   }
     *   // Request failed
     * }).catch(ex => {
     *   // Exception occured while processing request
     * });
     */

  }, {
    key: "profiles",
    value: function profiles() {
      var url = dbURL(this.url, this.db, this.appId, 'auth', 'profiles');
      return fetchAsync(url, Object.assign({}, this.options, {
        method: 'GET'
      }));
    }
    /**
     * Sends a sign in query to the server
     * @param {string} email - The user's email id.
     * @param {string} pass - The user's password.
     * @returns {Promise<AuthResponse>} Returns a promise containing response from server
     * @example 
     * db.signIn('demo@example.com', '1234').then(res => {
     *   if (res.status === 200) {
     *     // Set the token id to enable crud operations
     *     api.setToken(res.data.token)
     * 
     *     // res.data contains request payload
     *     console.log('Response:', res.data);
     *     return;
     *   }
     *   // Request failed
     * }).catch(ex => {
     *   // Exception occured while processing request
     * });
     */

  }, {
    key: "signIn",
    value: function signIn(email, pass) {
      var url = dbURL(this.url, this.db, this.appId, 'auth', 'email/signin');
      var body = JSON.stringify({
        email: email,
        pass: pass
      });
      return fetchAsync(url, Object.assign({}, this.options, {
        method: 'POST',
        body: body
      }));
    }
    /**
     * Sends a sign up query to the server
     * @param {string} email - The user's email id.
     * @param {string} name - The user's name.
     * @param {string} pass - The user's password.
     * @param {string} role - The user's role.
     * @returns {Promise<AuthResponse>} Returns a promise containing response from server
     * @example 
     * db.signUp('demo@example.com', 'UserName', '1234', 'default').then(res => {
     *   if (res.status === 200) {
     *     // Set the token id to enable crud operations
     *     api.setToken(res.data.token)
     *     
     *     // res.data contains request payload
     *     console.log('Response:', res.data);
     *     return;
     *   }
     *   // Request failed
     * }).catch(ex => {
     *   // Exception occured while processing request
     * });
     */

  }, {
    key: "signUp",
    value: function signUp(email, name, pass, role) {
      var url = dbURL(this.url, this.db, this.appId, 'auth', 'email/signup');
      var body = JSON.stringify({
        email: email,
        pass: pass,
        name: name,
        role: role
      });
      return fetchAsync(url, Object.assign({}, this.options, {
        method: 'POST',
        body: body
      }));
    }
  }]);

  return DB;
}();

var generateFind = function generateFind(condition) {
  switch (condition.type) {
    case 'and':
      var d = {};
      condition.clauses.forEach(function (clause) {
        var generated = generateFind(clause);

        if (clause.type == 'cond') {
          if (d[clause.f1] == undefined) {
            d = Object.assign(d, generated);
          } else {
            d[clause.f1] = Object.assign(d[clause.f1], generated[clause.f1]);
          }
        } else {
          d = Object.assign(d, generated);
        }
      });
      return d;

    case 'or':
      var newConds = condition.clauses.map(function (cond) {
        return generateFind(cond);
      });
      return {
        '$or': newConds
      };

    case 'cond':
      switch (condition.op) {
        case '==':
          return _defineProperty({}, condition.f1, condition.f2);

        case '>':
          return _defineProperty({}, condition.f1, {
            $gt: condition.f2
          });

        case '<':
          return _defineProperty({}, condition.f1, {
            $lt: condition.f2
          });

        case '>=':
          return _defineProperty({}, condition.f1, {
            $gte: condition.f2
          });

        case '<=':
          return _defineProperty({}, condition.f1, {
            $lte: condition.f2
          });

        case '!=':
          return _defineProperty({}, condition.f1, {
            $ne: condition.f2
          });

        case 'in':
          return _defineProperty({}, condition.f1, {
            $in: condition.f2
          });

        case 'notIn':
          return _defineProperty({}, condition.f1, {
            $nin: condition.f2
          });

        case 'regex':
          return _defineProperty({}, condition.f1, {
            $regex: condition.f2
          });

        case 'contains':
          return _defineProperty({}, condition.f1, {
            $contains: condition.f2
          });
      }

  }
};

var dbURL = function dbURL(prefix, db, appId, moduleName, suffix) {
  return "".concat(prefix, "v1/api/").concat(appId, "/").concat(moduleName, "/").concat(db, "/").concat(suffix);
};

exports.dbURL = dbURL;
exports.generateFind = generateFind;
exports.DB = DB;