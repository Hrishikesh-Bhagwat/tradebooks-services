"use strict";

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var db = require('./db');

var utils = require('../utils'),
    fetchAsync = utils.fetchAsync,
    and = utils.and;
/**
 * Class representing the DB Update Interface.
 * @example 
 * import { API, cond, or, and } from 'space-api';
 * 
 * const api = new API('my-project', 'http://localhost:4122');
 * const db = api.DB("mongo");
 * 
 * db.update('posts').where(and(cond('title', '==', 'Title1'))).set({ title: 'Title2' }).all().then(res => {
 *   if (res.status === 200) {
 *     // The documents were updated successfully
 *     return;
 *   }
 * }).catch(ex => {
 *   // Exception occured while processing request
 * });
 */


var Update =
/*#__PURE__*/
function () {
  /**
   * Create an instance of the DB Update Interface.
   * @param {string} appId 
   * @param {string} collection 
   * @param {string} url 
   * @param {Object} options 
   * @param {string} db
   * @param {string} op
   */
  function Update(appId, collection, url, options, db, op) {
    _classCallCheck(this, Update);

    this.appId = appId;
    this.collection = collection;
    this.url = url;
    this.db = db;
    this.options = Object.assign({}, options, {
      method: 'POST'
    });
    this.params = {
      find: {},
      update: {}
    };
    this.params.op = op;
    this.type = 'update';
  }
  /**
   * Prepares the find query
   * @param {...Object} conditions - The condition logic.
   */


  _createClass(Update, [{
    key: "where",
    value: function where() {
      this.params.find = db.generateFind(and.apply(void 0, arguments));
      return this;
    }
    /**
     * Sets the value of a field in a document.
     * @param {Object} obj - The Object containing fields to set.
     * @example
     * db.update('posts').set({ author: 'Drake' }).all().then(res => ...)
     */

  }, {
    key: "set",
    value: function set(obj) {
      this.params.update.$set = obj;
      return this;
    }
    /**
     * Adds an item to an array.
     * @param {Object} obj - The Object containing fields to set.
     * @example
     * db.update('posts').push({ author: 'Drake' }).all().then(res => ...)
     */

  }, {
    key: "push",
    value: function push(obj) {
      this.params.update.$push = obj;
      return this;
    }
    /**
     * Removes the specified field from a document.
     * @param {...string} fields - The fields to remove.
     * @example
     * db.update('posts').remove('age', 'likes').all().then(res => ...)
     */

  }, {
    key: "remove",
    value: function remove() {
      for (var _len = arguments.length, fields = new Array(_len), _key = 0; _key < _len; _key++) {
        fields[_key] = arguments[_key];
      }

      this.params.update.$unset = fields.reduce(function (prev, curr) {
        return Object.assign(prev, _defineProperty({}, curr, ''));
      }, {});
      return this;
    }
    /**
     * Renames the specified field.
     * @param {Object} obj - The object containing fields to rename.
     * @example
     * db.update('posts').rename({ mobile: 'contact' }).all().then(res => ...)
     */

  }, {
    key: "rename",
    value: function rename(obj) {
      this.params.update.$rename = obj;
      return this;
    }
    /**
     * Increments the value of the field by the specified amount.
     * @param {Object} obj - The object containing fields to increment along with the value.
     * @example
     * // The value of added with 1
     * db.update('posts').inc({ views: 1 }).all().then(res => ...)
     */

  }, {
    key: "inc",
    value: function inc(obj) {
      this.params.update.$inc = obj;
      return this;
    }
    /**
     * Multiplies the value of the field by the specified amount.
     * @param {Object} obj - The object containing fields to multiply along with the value.
     * @example
     * // The value of amount will be multiplied by 4
     * db.update('posts').mul({ amount: 4 }).all().then(res => ...)
     */

  }, {
    key: "mul",
    value: function mul(obj) {
      this.params.update.$mul = obj;
      return this;
    }
    /**
     * Only updates the field if the specified value is greater than the existing field value.
     * @param {Object} obj - The object containing fields to set.
     * @example
     * db.update('posts').max({ highScore: 1200 }).all().then(res => ...)
     */

  }, {
    key: "max",
    value: function max(obj) {
      this.params.update.$max = obj;
      return this;
    }
    /**
     * Only updates the field if the specified value is lesser than the existing field value.
     * @param {Object} obj - The object containing fields to set.
     * @example
     * db.update('posts').min({ lowestScore: 300 }).all().then(res => ...)
     */

  }, {
    key: "min",
    value: function min(obj) {
      this.params.update.$min = obj;
      return this;
    }
    /**
     * Sets the value of a field to current timestamp.
     * @param {...string} values - The fields to set.
     * @example
     * db.update('posts').currentTimestamp('lastModified').all().then(res => ...)
     */

  }, {
    key: "currentTimestamp",
    value: function currentTimestamp() {
      for (var _len2 = arguments.length, values = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        values[_key2] = arguments[_key2];
      }

      this.params.update.$currentDate = Object.assign({}, this.params.update.$currentDate, values.reduce(function (prev, curr) {
        return Object.assign(prev, _defineProperty({}, curr, {
          $type: 'timestamp'
        }));
      }, {}));
      return this;
    }
    /**
     * Sets the value of a field to current date.
     * @param {...string} values - The fields to set.
     * @example
     * db.update('posts').currentDate('lastModified').all().then(res => ...)
     */

  }, {
    key: "currentDate",
    value: function currentDate() {
      for (var _len3 = arguments.length, values = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        values[_key3] = arguments[_key3];
      }

      this.params.update.$currentDate = Object.assign({}, this.params.update.$currentDate, values.reduce(function (prev, curr) {
        return Object.assign(prev, _defineProperty({}, curr, {
          $type: 'date'
        }));
      }, {}));
      return this;
    }
    /**
    * Makes the query to update a single document which matches first.
    * @returns {Promise} Returns a promise containing response from server
    * @deprecated Since version 0.4.3. Will be deleted in version 1.0.0. Use apply instead.
    */

  }, {
    key: "one",
    value: function one() {
      this.params.op = 'one';
      this.options.body = JSON.stringify(this.params);
      var url = db.dbURL(this.url, this.db, this.appId, 'crud', "".concat(this.collection, "/update"));
      return fetchAsync(url, this.options);
    }
    /**
    * Makes the query to update all documents which matches.
    * @returns {Promise} Returns a promise containing response from server
    * @deprecated Since version 0.4.3. Will be deleted in version 1.0.0. Use apply instead.
    */

  }, {
    key: "all",
    value: function all() {
      this.params.op = 'all';
      this.options.body = JSON.stringify(this.params);
      var url = db.dbURL(this.url, this.db, this.appId, 'crud', "".concat(this.collection, "/update"));
      return fetchAsync(url, this.options);
    }
    /**
    * Makes the query to update all documents which matches.
    * @returns {Promise} Returns a promise containing response from server
    */

  }, {
    key: "apply",
    value: function apply() {
      this.options.body = JSON.stringify(this.params);
      var url = db.dbURL(this.url, this.db, this.appId, 'crud', "".concat(this.collection, "/update"));
      return fetchAsync(url, this.options);
    }
    /**
    * Makes the query to update all, else insert a document.
    * @returns {Promise} Returns a promise containing response from server
    */

  }, {
    key: "upsert",
    value: function upsert() {
      this.params.op = 'upsert';
      this.options.body = JSON.stringify(this.params);
      var url = db.dbURL(this.url, this.db, this.appId, 'crud', "".concat(this.collection, "/update"));
      return fetchAsync(url, this.options);
    }
  }]);

  return Update;
}();

module.exports = Update;