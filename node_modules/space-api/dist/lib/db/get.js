"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var db = require('./db');

var utils = require('../utils'),
    fetchAsync = utils.fetchAsync,
    and = utils.and;
/**
 * Class representing the DB Get Interface.
 * @example 
 * import { API, cond, or, and } from 'space-api';
 * 
 * const api = new API('my-project', 'http://localhost:4122');
 * const db = api.DB("mongo");
 * 
 * db.get('posts').where(and(cond('title', '==', 'Title1'))).all().then(res => {
 *   if (res.status === 200) {
 *     // res.data contains the documents returned by the database
 *     console.log('Response:', res.data);
 *     return;
 *   }
 * }).catch(ex => {
 *   // Exception occured while processing request
 * });
 */


var Get =
/*#__PURE__*/
function () {
  /**
   * Create an instance of the DB Get Interface.
   * @param {string} appId 
   * @param {string} collection 
   * @param {string} url 
   * @param {Object} options 
   * @param {string} db 
   * @param {string} op 
   */
  function Get(appId, collection, url, options, db, op) {
    _classCallCheck(this, Get);

    this.appId = appId;
    this.collection = collection;
    this.url = url;
    this.db = db;
    this.options = Object.assign({}, options, {
      method: 'POST'
    });
    this.params = {
      find: {},
      options: {},
      aggregate: {}
    };
    this.params.op = op;
    this.type = 'read';
  }
  /**
   * Prepares the find query
   * @param {...Object} conditions - The condition logic.
   */


  _createClass(Get, [{
    key: "where",
    value: function where() {
      this.params.find = db.generateFind(and.apply(void 0, arguments));
      return this;
    }
  }, {
    key: "whereRaw",
    value: function whereRaw(condition) {
      this.params.find = condition;
      return this;
    }
    /**
     * Sets the fields to be selected
     * @param {Object} select - The select object.
     * @example
     * // Given query will only select author and title fields
     * const select = { author: 1, title: 1 }
     * db.get('posts').select(select).all().then(res => ...)
     */

  }, {
    key: "select",
    value: function select(_select) {
      this.params.options.select = _select;
      return this;
    }
    /**
     * Sets the fields to groupBy
     * @param {...string} array - The fields to perform group by operation.
     * @example
     * db.get('expenditures').groupBy('category', 'userId').aggregateCount('amount').apply().then(res => ...)
     */

  }, {
    key: "groupBy",
    value: function groupBy() {
      for (var _len = arguments.length, array = new Array(_len), _key = 0; _key < _len; _key++) {
        array[_key] = arguments[_key];
      }

      this.params.group = array;
      return this;
    }
    /**
     * Sets the fields to perform count aggregation on
     * @param {...string} array - The fields to perform count aggregation on.
     * @example
     * db.get('expenditures').groupBy('category').aggregateCount('amount').apply().then(res => ...)
     */

  }, {
    key: "aggregateCount",
    value: function aggregateCount() {
      for (var _len2 = arguments.length, array = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        array[_key2] = arguments[_key2];
      }

      this.params.aggregate.count = array;
      return this;
    }
    /**
     * Sets the fields to perform max aggregation on
     * @param {...string} array - The fields to perform max aggregation on.
     * @example
     * db.get('expenditures').groupBy('category').aggregateMax('amount').apply().then(res => ...)
     */

  }, {
    key: "aggregateMax",
    value: function aggregateMax() {
      for (var _len3 = arguments.length, array = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        array[_key3] = arguments[_key3];
      }

      this.params.aggregate.max = array;
      return this;
    }
    /**
     * Sets the fields to perform min aggregation on
     * @param {...string} array - The fields to perform min aggregation on.
     * @example
     * db.get('expenditures').groupBy('category').aggregateMin('amount').apply().then(res => ...)
     */

  }, {
    key: "aggregateMin",
    value: function aggregateMin() {
      for (var _len4 = arguments.length, array = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        array[_key4] = arguments[_key4];
      }

      this.params.aggregate.min = array;
      return this;
    }
    /**
     * Sets the fields to perform average aggregation on
     * @param {...string} array - The fields to perform average aggregation on.
     * @example
     * db.get('expenditures').groupBy('category').aggregateAverage('amount').apply().then(res => ...)
     */

  }, {
    key: "aggregateAverage",
    value: function aggregateAverage() {
      for (var _len5 = arguments.length, array = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        array[_key5] = arguments[_key5];
      }

      this.params.aggregate.avg = array;
      return this;
    }
    /**
     * Sets the fields to perform sum aggregation on
     * @param {...string} array - The fields to perform sum aggregation on.
     * @example
     * db.get('expenditures').groupBy('category').aggregateSum('amount').apply().then(res => ...)
     */

  }, {
    key: "aggregateSum",
    value: function aggregateSum() {
      for (var _len6 = arguments.length, array = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
        array[_key6] = arguments[_key6];
      }

      this.params.aggregate.sum = array;
      return this;
    }
    /**
     * Sets the fields to sort result by.
     * @param {...string} array - The fields to sort result by.
     * @example
     * // Given query will sort results first by age (asc) then by age (desc)
     * db.get('posts').sort('title', '-age').all().then(res => ...)
     */

  }, {
    key: "sort",
    value: function sort() {
      for (var _len7 = arguments.length, array = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
        array[_key7] = arguments[_key7];
      }

      this.params.options.sort = array;
      return this;
    }
    /**
     * Sets the number of documents to skip in the array. 
     * @param {number} num - The number of documents to skip.
     * @example
     * // Given query will skip the first 10 documents
     * db.get('posts').skip(10).all().then(res => ...)
     */

  }, {
    key: "skip",
    value: function skip(num) {
      this.params.options.skip = num;
      return this;
    }
    /**
     * Sets the limit on number of documents returned by the query. 
     * @param {number} num - The limit on number of documents.
     * @example
     * // Given query will limit the result to 10 documents
     * db.get('posts').limit(10).all().then(res => ...)
     */

  }, {
    key: "limit",
    value: function limit(num) {
      this.params.options.limit = num;
      return this;
    }
    /**
     * Makes the query to return a single document as an object. If no documents are returned, the status code is 400. 
     * @returns {Promise} Returns a promise containing response from server.
     * @example
     * db.get('posts').one().then(res => ...)
     * @deprecated Since version 0.4.3. Will be deleted in version 1.0.0. Use apply instead.
     */

  }, {
    key: "one",
    value: function one() {
      this.params.op = 'one';
      this.options.body = JSON.stringify(this.params);
      var url = db.dbURL(this.url, this.db, this.appId, 'crud', "".concat(this.collection, "/read"));
      return fetchAsync(url, this.options);
    }
    /**
     * Makes the query to return multiple documents as an array. It is possible for an empty array to be returned. 
     * @returns {Promise} Returns a promise containing response from server.
     * @example
     * db.get('posts').all().then(res => ...)
     * @deprecated Since version 0.4.3. Will be deleted in version 1.0.0. Use apply instead.
     */

  }, {
    key: "all",
    value: function all() {
      this.params.op = 'all'; // Set a default limit if offset is specified and limit is not specified.

      if (this.params.options.skip !== undefined && this.params.options.limit === undefined) {
        this.params.options.limit = 20;
      }

      this.options.body = JSON.stringify(this.params);
      var url = db.dbURL(this.url, this.db, this.appId, 'crud', "".concat(this.collection, "/read"));
      return fetchAsync(url, this.options);
    }
    /**
     * Makes the query to return multiple documents as an array. It is possible for an empty array to be returned. 
     * @returns {Promise} Returns a promise containing response from server.
     * @example
     * db.get('posts').apply().then(res => ...)
     */

  }, {
    key: "apply",
    value: function apply() {
      // Set a default limit if offset is specified and limit is not specified.
      if (this.params.options.skip !== undefined && this.params.options.limit === undefined) {
        this.params.options.limit = 20;
      }

      this.options.body = JSON.stringify(this.params);
      var url = db.dbURL(this.url, this.db, this.appId, 'crud', "".concat(this.collection, "/read"));
      return fetchAsync(url, this.options);
    }
    /**
    * Makes the query to return an array of all the distinct values for the given field. It is possible for an empty array to be returned. 
    * @returns {Promise} Returns a promise containing response from server.
    * @example
    * db.get('posts').distinct('category').then(res => ...)
    * @deprecated Since version 0.4.3. Will be deleted in version 1.0.0. Use apply instead.
    */

  }, {
    key: "distinct",
    value: function distinct(key) {
      this.params.op = 'distinct';
      this.params.options.distinct = key;
      this.options.body = JSON.stringify(this.params);
      var url = db.dbURL(this.url, this.db, this.appId, 'crud', "".concat(this.collection, "/read"));
      return fetchAsync(url, this.options);
    }
    /**
     * Makes the query to return the count of total number of documents that were queried. 
     * @example
     * // Given query counts the total number of posts in the 'posts' collection
     * db.get('posts').count().then(res => ...)
     * @deprecated Since version 0.4.3. Will be deleted in version 1.0.0. Use apply instead.
     */

  }, {
    key: "count",
    value: function count() {
      this.params.op = 'count';
      this.options.body = JSON.stringify(this.params);
      var url = db.dbURL(this.url, this.db, this.appId, 'crud', "".concat(this.collection, "/read"));
      return fetchAsync(url, this.options);
    }
  }]);

  return Get;
}();

module.exports = Get;