"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var db = require('../db/db');

var and = require('../utils').and;

var WebSocketClient = require('../websocket/websocket-client').WebSocketClient;

var generateId = require('../utils').generateId;

var snapshotCallback = require('./helper').snapshotCallback;

var LiveQuerySubscription = require('./subscription');
/**
 * Class representing the LiveQuery Interface.
 * @example
 * import { API, cond, or, and } from 'space-api';
 * const api = new API('my-project');
 * 
 * // Create database instance
 * const db = api.DB("mongo");
 * 
 * const onSnapshot  = (docs, type, find, changedDoc) => {
 *    console.log(docs, type, find, changedDoc)
 *  }
 *
 *  const onError = (err) => {
 *    console.log('Live query error', err)
 *  }
 *
 *  let subscription = db.liveQuery('posts').where({}).subscribe(onSnapshot, onError) 
 *
 *  subscription.unsubscribe()
 */


var LiveQuery =
/*#__PURE__*/
function () {
  /**
   * Create an instance of the LiveQuery Interface.
   * @param {string} appId 
   * @param {string} db 
   * @param {string} collection 
   * @param {WebSocketClient} client 
   * @param {Object} store 
   */
  function LiveQuery(appId, db, collection, client, store) {
    _classCallCheck(this, LiveQuery);

    this.appId = appId;
    this.db = db;
    this.collection = collection;
    this.client = client;
    this.store = store;
    this.params = {
      find: {}
    };
    this.opts = {
      skipInitial: false
    };
  }
  /**
   * Prepares the find query
   * @param {...Object} conditions - The condition logic.
   */


  _createClass(LiveQuery, [{
    key: "where",
    value: function where() {
      this.find = db.generateFind(and.apply(void 0, arguments));
      return this;
    }
    /**
     * Sets the options for the live query
     * @param {Object} opts - The options. (Of the form { changesOnly: true|false })
     */

  }, {
    key: "options",
    value: function options(opts) {
      if (opts != {}) {
        this.opts = opts;
      }

      return this;
    }
  }, {
    key: "skipInitial",
    value: function skipInitial() {
      this.opts.skipInitial = true;
    }
  }, {
    key: "addSubscription",
    value: function addSubscription(id, onSnapshot, onError) {
      var _this = this;

      var subscription = {
        onSnapshot: onSnapshot,
        onError: onError
      };
      this.store[this.db][this.collection][id].subscription = subscription;
      return function () {
        // TODO: Handle the errors for realtime-unsubscribe
        _this.client.request('realtime-unsubscribe', {
          group: _this.collection,
          dbType: _this.db,
          id: id,
          options: _this.opts
        });

        delete _this.store[_this.db][_this.collection][id];
      };
    }
    /** 
     * Callback for realtime updates to the subscribed data 
     *  @name OnSnapshot
     *  @function
     *  @param {Array} docs The updated docs
     *  @param {string} type The type of operation performed
     *  @param {Object} find The object containing those fields of the concerned doc that form it's unique identity (i.e the primary field or the fields in a unique index)
     *  @param {Object} changedDoc The doc that changed
     */

    /** 
     * Callback for error while subscribing
     *  @name OnError
     *  @function
     *  @param {string} err - Error during the liveSubscribe
     */

    /** 
     *  The function to unsubscribe the subscription
     *  @name Unsubscribe
     *  @function
     */

    /**
     * Subscribes for real time updates
     * @param {OnSnapshot} onSnapshot - OnSnapshot callback
     * @param {OnError} onError - OnError callback
     * @returns {Unsubscribe} Returns a unsubscribe function
     */

  }, {
    key: "subscribe",
    value: function subscribe(onSnapshot, onError) {
      var id = generateId();
      return this.subscribeRaw(id, onSnapshot, onError);
    }
  }, {
    key: "subscribeRaw",
    value: function subscribeRaw(id, onSnapshot, onError) {
      var _this2 = this;

      var req = {
        id: id,
        group: this.collection,
        where: this.find,
        dbType: this.db,
        project: this.appId,
        options: this.opts
      };

      if (!this.store[this.db]) {
        this.store[this.db] = {};
      }

      if (!this.store[this.db][this.collection]) {
        this.store[this.db][this.collection] = {};
      }

      this.store[this.db][this.collection][id] = {
        snapshot: [],
        subscription: {},
        find: this.find,
        opts: this.opts // Add subscription to store

      };
      var unsubscribe = this.addSubscription(id, onSnapshot, onError); // Send subscribe request to server

      this.client.request('realtime-subscribe', req).then(function (data) {
        // Unsubscribe if ack is false
        if (!data.ack) {
          onError(data.error);
          unsubscribe();
          return;
        }

        snapshotCallback(_this2.store, data.docs);
      }).catch(function (e) {
        // Unsubscribe on error
        onError(e);
        unsubscribe();
      });
      this.store[this.db][this.collection][id].subscriptionObject = new LiveQuerySubscription(unsubscribe, []);
      return this.store[this.db][this.collection][id].subscriptionObject;
    }
  }]);

  return LiveQuery;
}();

module.exports = LiveQuery;